---
title: "Importing data"
author: "Nozimjon Ortiqov"
date: "'Sys.Date()'"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE,
  warning = FALSE
  )
```

## Libraries

```{r}
library(readr) #importing (reading)/exporting (writing) tabular data
library(readxl) #importing excel files
library(here)
library(tidyverse)
here()
```

## Data format

-   tabular/delimited data (csv, text etc)
-   spreadsheets (excel, googlesheets)
-   dta (stata), SPSS
-   spatial data
-   sql

### Comma separated values (csv)

![](import_data/mtcars_comma.png)

### Semi Colon Separated Values

![](import_data/mtcars_semicolon.png)

### Space Separated Values

### ![](import_data/mtcars_space.png)

### Tab Separated Values

![](import_data/mtcars_tab.png)

## Read Data

Let us begin by reading data from a `csv` file using `read_csv()`.

```{r}
read_csv('data/hsb2.csv', show_col_types = TRUE) 
```

Great! If you see the above output, you have successfully read data into
R. If you see an error message (which most of us see when we are trying
to read data for the first time), follow the below instructions:

-   check the separator in the file and ensure it is a `comma`

-   check the file name

-   check the file path i.e. location of the file

-   ensure that the file name or path is enclosed in single or double
    quotes

When you read data using `readr`, it will display the data type detected
for each column/variable in the data set. If you want to check the data
types before reading the data, use `spec_csv()`. We will learn to
specify the column types in the next section.

```{r}
spec_csv('data/hsb2.csv') 
```

## Column Names

In some cases, files do not include **column names** or headers. If we
do not indicate the absence of column names, `readr` will treat the
first row from the data as the column name. Like we said before, it is a
good practice to take a quick look at the data to check for the
presence/absence of column names.

![](import_data/mtcars_column_false.png)

We will first read the data set without indicating the presence or
absence of column names.

```{r}
read_csv('data/hsb3.csv') 
```

As you can see, in the absence of column names, `readr` has converted
the first row of the data into the column names. As a result, the data
is not read properly and there are lots of missing values and warnings.
If the column names are absent (i.e. the column names are provided in a
separate file), use the `col_names` argument and set it to `FALSE`. Now
`readr` will not convert the first row of data into column name and
instead it will generate new column names.

```{r}
read_csv('data/hsb3.csv', col_names = FALSE)
```

We may not always want to use the column names generated by `readr` and
instead specify new column names. In such cases, we can use `col_names`
to supply column names as shown in the below example. Let us reread
`hsb3` and specify column names.

```{r}
cnames <- c("id", "gender", "race", "socio_economic_status", "school_type", "program", "read", "write", "math", "science", "socst")

read_csv('import_data/data/hsb3.csv', col_names = cnames)
```

### Skip Lines

In certain files, you will find information related to the data such as:

-   the data source

-   column names

-   column description

-   copyright etc.

The data will appear after/below such text/information. While reading
data from such files, we need to skip all the rows where the text is
present. If we do not skip them, `readr` will consider them as part of
the data.

![](import_data/mtcars_skip.png)

Let us read the data without skipping any lines/rows and observe the
result.

```{r}
read_csv('import_data/data/hsb4.csv')
```

Use `skip` argument to indicate the number of lines/rows to be skipped
while reading data from a file. For example, if the file has contents
other than data in the first few lines, we need to skip them before
reading the data. In the below example, we will skip the first 3 lines
as they contain information about the data set which we do not need.

```{r}

read_csv('import_data/data/hsb4.csv', skip = 25)

```

### Maximum Lines

Suppose the data file contains several thousands of rows of data and we
do not want to read all of it. What can we do in such cases? `readr`
allows us to specify the maximum number of rows to be read using the
`n_max` argument. Suppose we want to read only 100 rows of data from a
file, we can set `n_max` equal to 100. In the next example, we will read
the first 120 rows from the `hsb2` file. If you observe the last row in
the output, it says `# ... with 110 more rows`, indicating that only 120
rows of data has been read from the file.

```{r}
read_csv('import_data/data/hsb2.csv', n_max = 120)
```

### Column Types

f you have observed carefully, when you read data using `readr`, it
displays the column names and column types followed by the first 10 rows
of data. `readr` determines the data type for each column based on the
first 1000 rows of data. The data can be of the following types:

-   integer

-   double (decimal point)

-   logical (TRUE/FALSE)

-   character (text/string)

-   factor (categorical/qualitative)

-   date/time

![](import_data/column_types_list_canva.png)

Before you read data from a file, use `spec_csv()` to see the data types
as determined by `readr`. If it determines the data types correctly, you
can go ahead and read the data else we will have to specify the data
types and we will have to do that for all the columns we want to read
and not just for those columns whose data type was wrongly determined by
`readr`.

To specify the data types, we will use the `col_types` argument and
supply it a list of data types. The data types can be specified using:

-   `col_integer()`

-   `col_double()`

-   `col_factor()`

-   `col_logical()`

-   `col_character()`

-   `col_date()`

-   `col_time()`

-   `col_datetime()`

While specifying the data types we also need to specify the categories
of the categorical/qualitative variable. To do that, we use the `levels`
argument within `col_factor()`. Let us read data from the `hsb2.csv`
file to understand data type specification.

```{r}
read_csv('import_data/data/hsb1.csv', col_types = list(
  col_integer(), col_factor(), 
  col_factor(), col_factor(), 
  col_factor(), col_factor(),
  col_integer(), col_integer(), col_integer(), col_integer(),
  col_integer())            
)

```

If we do not specify the data type for all columns, `readr` will return
an error which leads to the following questions:

1.  What if I want to skip a few columns?

2.  What if I want to read certain columns only?

### Specific Columns

![](import_data/column_objective_function_map.png)

For the first scenario, we can use `col_skip()` i.e. instead of
specifying the data type, we indicate to `readr` to skip that particular
column while reading the data.

In case of the second scenario, we will use `cols_only()` to specify the
columns to be read i.e. instead of using `list()` to supply the data
types, we will use `cols_only()` and provide the following details:

-   column name

-   column type using `col_types` argument

```{r}
read_csv('import_data/data/hsb2.csv', col_types = cols_only(id = col_integer(), prog = col_factor(), read = col_integer())
)
```

If you have a data set with 10 columns and plan to skip only a couple of
columns, use `col_skip()` instead if you plan to read only a couple of
columns, use `cols_only()`.

## Summary

In this post, we explored:

-   reading data from flat/delimited files

-   indicating the presence/absence of column names

-   skipping rows in the presence of text/information

-   specifying maximum rows to be read

-   specifying column data types

-   skipping columns

-   reading specific columns only

In the next post, we will explore reading data from excel spreadsheets
and other statistical softwares.

Reading excel data

```{r}
library(readxl)
```

```{r}
# read Excel file into R
df_excel <- read_excel("data/mehnatuz_december (2).xlsx")
```

```{r}
# read example file into R
example <- readxl_example("datasets.xlsx")
df <- read_excel(example)
df
```

#Bir nechta argumentlari mavjud, eng muhimlari quyidagilar:

*sheet - qaysi listni olishni ko'rsatadi* col_names - birinchi ustum
ustun nomlari sifatida qaralishi kerak yoki yo'qligini/ustun nomlarni
bir paytda o'zgartirish imkonini ham beradi \* skip - ma'lumotlarni
o'qishda dastlabki bir nechta qatorni tashlab ketish kerakligini
ko'rsatadi

```{r}
misol_data <- read_excel("data/deaths.xlsx", sheet = 2)
```

Read in an Excel file and skip the second row only Use indexing [] to
drop the second row. Indexing is [row,column]. Note: Notice that I drop
row 1 because [-1,] happens after R reads in the Excel file. The first
row of the Excel file is read in as the column names (because I left the
default col_names=TRUE) so the second row of the Excel file will become
the first row of the R data frame

```{r}
misol_data <- readxl::read_excel("data/deaths.xlsx")[-1,]
```

```{r}
# specify column names on import
read_excel(example, col_names = LETTERS[1:5], skip = 1)
```

### Ma'lumotlarni o'qishda ustun nomlarni birdaniga o'zgartirish mumkin

```{r}
new_names <- c("a", "b", "c", "gender", "region", "district", "age", "education", "is_working", "is_official",  "q_1", "q_2", "q_3", "income","q_4", "q_5", "q_6", 
    "q_7", "q_8", "q_9", "q_10") 
fargona <- read_excel("data/fergana.xlsx", col_names = new_names, skip = 1)
```

### Qo'shimcha argumentlar

.name_repair = "unique"

```{r}
# read example file into R using .name_repair default
read_excel(
  readxl_example("deaths.xlsx"),
  range = "arts!A5:F8",
  .name_repair = "unique"
)
```

.name_repair = "universal"

```{r}
# require use of universal naming conventions
read_excel(
  readxl_example("deaths.xlsx"),
  range = "arts!A5:F8",
  .name_repair = "universal"
)
```

# read.csv (Base R) vs read_csv (tidyverse)
